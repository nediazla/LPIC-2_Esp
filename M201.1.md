# 1. Planificación de la capacidad

## 1.1 Medir y solucionar problemas relacionados con la utilización de recursos

La planificación de capacidad consiste en medir, entender y anticipar el uso de recursos del sistema: CPU, memoria, E/S de disco, red y procesos.

### Métricas fundamentales
- **CPU**: carga, uso por núcleo, procesos esperados/runnable.
- **Memoria**: libre, usada, buffers, caché, swap.
- **Disco**: latencia, throughput, IOPS.
- **Red**: velocidad, errores, tráfico, colisiones.
- **Procesos**: estados (D, R, S, Z), hilos, prioridades.

---

### Medición del uso de CPU

Uso en tiempo real:
```
top
htop
```

Ver promedios de carga:
```
uptime
cat /proc/loadavg
```

Explicación `/proc/loadavg`:
```
1.02 0.80 0.55 3/256 1453
│    │    │    │      └─ PID último proceso
│    │    │    └──────── procesos ejecutables/total
│    │    └───────────── carga 15 min
│    └────────────────── carga 5 min
└──────────────────────── carga 1 min
```

Carga por núcleo:
```
mpstat -P ALL 1
```

---

### Medición de memoria

Ver uso general:
```
free -h
```

Analizar memoria y swap:
```
vmstat 1
```

Ver memoria por proceso:
```
ps aux --sort=-%mem | head
```

Información detallada:
```
cat /proc/meminfo
```

---

### Medición de E/S de disco

`iostat`:
```
iostat -xz 1
```

Parámetros clave:
- **%util** → saturación del disco  
- **await** → latencia  
- **r/s, w/s** → operaciones por segundo  
- **svctm** → tiempo de servicio (deprecated pero útil en algunos SO)

Ver latencia por dispositivo:
```
iotop
```

Ver actividad detallada:
```
dstat -d 1
```

---

### Medición de red

Estadísticas generales:
```
ip -s link
```

Ver conexiones activas:
```
ss -tulnp
```

Tráfico en tiempo real:
```
nload
ifstat
bmon
```

Errores de interfaz:
```
ethtool -S eth0
```

---

### Análisis de procesos

Ver procesos por CPU:
```
ps aux --sort=-%cpu | head
```

Árbol de procesos:
```
pstree -p
```

Estados importantes:
```
R = runnable
S = sleeping
D = uninterruptible I/O (problemas de disco)
Z = zombie
```

Ver bloqueos y esperas de E/S:
```
iotop -o
```

---

### Detección de cuellos de botella
- **CPU alta** → procesos mal optimizados, hilos bloqueados, cargas anómalas.
- **Memoria baja** → swapping, OOM-killer.
- **Disco saturado** → %util > 80%, await alto.
- **Red saturada** → errores RX/TX, colisiones.
- **Procesos en estado D** → fallos de discos o NFS.

Detectar OOM (out of memory):
```
journalctl -k | grep -i kill
```

---

## 1.2 Predecir la necesidad de futuros recursos

Consiste en evaluar tendencias para anticipar necesidades.

### Herramientas de monitoreo histórico

RRDtool (base histórica de series temporales):
```
rrdtool create, update, graph ...
```

Collectd (agente de métricas):
```
collectd
/var/lib/collectd/
```

Munin (monitoreo histórico web):
```
apt install munin-node
```

Prometheus + Node Exporter:
```
node_exporter
prometheus
```

Grafana para dashboards:
```
http://localhost:3000
```

---

### Proyección de tendencias

Basarse en:
- crecimiento del uso de CPU por semana/mes
- crecimiento del uso de RAM
- crecimiento del %util del almacenamiento
- incremento de peticiones en servidores web
- latencia creciente de red o disco

Ejemplo: obtener uso de disco a lo largo del tiempo:
```
df -h
```
Registrar datos diariamente y calcular:
```
% crecimiento = (uso_final - uso_inicial) / días
```

---

### Análisis de logs para tendencias
```
journalctl --since "7 days ago" | grep -i error
```

Crecer en:
- fallos de I/O
- reinicios de servicios
- procesos que mueren regularmente

---

### Previsión de recursos en virtualización
Medir:
- CPU steal (`vmstat`)
- saturación del host
- tiempo de espera de I/O

```
vmstat 1 | awk '{print $6}'   # steal
```

Steal alto = necesidad de más vCPU en el host o menor sobreasignación.

---

### Planificación basada en SLAs
Los recursos deben garantizar:
- tiempo de respuesta
- disponibilidad
- throughput

Esto guía cuándo comprar hardware nuevo, añadir nodos o migrar cargas.
